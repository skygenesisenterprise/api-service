name: Release

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag'
        required: true

permissions:
  contents: write
  id-token: write
  packages: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      tag_name: ${{ steps.create_release.outputs.tag_name }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 8

    - name: Get pnpm store directory
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

    - name: Setup pnpm cache
      uses: actions/cache@v3
      with:
        path: ${{ env.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-

    - name: Setup Rust
      uses: actions-rust-lang/setup-rust-toolchain@v1

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    # Build artifacts
    - name: Build frontend
      run: pnpm run build

    - name: Build backend
      run: cargo build --release

    # Create release archives
    - name: Create release archives
      run: |
        # API binary
        tar -czf api-service-${{ github.ref_name }}-linux-x64.tar.gz target/release/api-service

        # Frontend build
        tar -czf frontend-${{ github.ref_name }}.tar.gz app/.next public package.json

        # Source code
        tar -czf source-${{ github.ref_name }}.tar.gz --exclude='.git' --exclude='target' --exclude='node_modules' .

    # Generate SBOM
    - name: Generate SBOM
      run: |
        npx @cyclonedx/cli generatebom --output sbom.json
        cargo cyclonedx --output-file rust-sbom.json
        npx @cyclonedx/cli merge --input-files sbom.json rust-sbom.json --output-file release-sbom.json

    # Sign artifacts
    - name: Import GPG key
      uses: crazy-max/ghaction-import-gpg@v5
      with:
        gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
        passphrase: ${{ secrets.GPG_PASSPHRASE }}

    - name: Sign artifacts
      run: |
        for file in *.tar.gz; do
          gpg --detach-sign --armor "$file"
        done
        gpg --detach-sign --armor release-sbom.json

    # Verify signatures
    - name: Verify signatures
      run: |
        for file in *.tar.gz; do
          gpg --verify "$file.asc" "$file"
        done
        gpg --verify release-sbom.json.asc release-sbom.json

    # Attest build provenance
    - name: Attest build provenance
      uses: actions/attest-build-provenance@v3
      with:
        subject-path: |
          api-service-*.tar.gz
          frontend-*.tar.gz
          source-*.tar.gz
          release-sbom.json

    # Upload artifacts
    - name: Upload release assets
      uses: softprops/action-gh-release@v2
      with:
        files: |
          api-service-*.tar.gz
          api-service-*.tar.gz.asc
          frontend-*.tar.gz
          frontend-*.tar.gz.asc
          source-*.tar.gz
          source-*.tar.gz.asc
          release-sbom.json
          release-sbom.json.asc
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Publish to package registries
  publish:
    name: Publish Packages
    runs-on: ubuntu-latest
    needs: release
    if: startsWith(github.ref, 'refs/tags/')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 8

    - name: Get pnpm store directory
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

    - name: Setup pnpm cache
      uses: actions/cache@v3
      with:
        path: ${{ env.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-

    - name: Setup Rust
      uses: actions-rust-lang/setup-rust-toolchain@v1

    # Publish to npm (if applicable)
    - name: Publish to npm
      run: |
        npm config set //registry.npmjs.org/:_authToken ${{ secrets.NPM_TOKEN }}
        npm publish
      continue-on-error: true

    # Publish to crates.io (if applicable)
    - name: Publish to crates.io
      run: |
        cargo login ${{ secrets.CRATES_IO_TOKEN }}
        cargo publish
      continue-on-error: true

    # Extract version and type from release tag
    - name: Extract version and type from tag
      id: extract-info
      run: |
        # Extract version and type from tag
        # Supports both formats: "web-v1.2.6" and "api-web-v1.2.6"
        TAG="${{ github.ref_name }}"
        
        # Detect tag type and extract version
        if [[ "$TAG" =~ ^api-web-v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
          TYPE="web"
          VERSION="${BASH_REMATCH[1]}"
          IMAGE_NAME="api-web"
          DOCKERFILE="Dockerfile.frontend"
        elif [[ "$TAG" =~ ^web-v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
          TYPE="web"
          VERSION="${BASH_REMATCH[1]}"
          IMAGE_NAME="api-web"
          DOCKERFILE="Dockerfile.frontend"
        elif [[ "$TAG" =~ ^api-cli-v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
          TYPE="cli"
          VERSION="${BASH_REMATCH[1]}"
          IMAGE_NAME="api-cli"
          DOCKERFILE="Dockerfile.cli"
        elif [[ "$TAG" =~ ^cli-v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
          TYPE="cli"
          VERSION="${BASH_REMATCH[1]}"
          IMAGE_NAME="api-cli"
          DOCKERFILE="Dockerfile.cli"
        elif [[ "$TAG" =~ ^api-service-v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
          TYPE="service"
          VERSION="${BASH_REMATCH[1]}"
          IMAGE_NAME="api-service"
          DOCKERFILE="Dockerfile.api"
        elif [[ "$TAG" =~ ^api-v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
          TYPE="all-in-one"
          VERSION="${BASH_REMATCH[1]}"
          IMAGE_NAME="api"
          DOCKERFILE="Dockerfile.all-in-one"
        else
          echo "Unsupported tag format. Expected formats:"
          echo "  - api-web-vX.X.X or web-vX.X.X (for web interface)"
          echo "  - api-cli-vX.X.X or cli-vX.X.X (for CLI)"
          echo "  - api-service-vX.X.X (for API service backend)"
          echo "  - api-vX.X.X (for All-in-One image)"
          exit 1
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "type=$TYPE" >> $GITHUB_OUTPUT
        echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
        echo "dockerfile=$DOCKERFILE" >> $GITHUB_OUTPUT
        echo "Tag: $TAG"
        echo "Type: $TYPE"
        echo "Version: $VERSION"
        echo "Image Name: $IMAGE_NAME"
        echo "Dockerfile: $DOCKERFILE"

    # Publish Docker images
    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ secrets.GITHUB_USERNAME }}
        password: ${{ secrets.GITHUB_TOKEN }}

    # Build and push image based on tag type
    - name: Build and push ${{ steps.extract-info.outputs.type }} image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./infrastructure/docker/${{ steps.extract-info.outputs.dockerfile }}
        push: true
        tags: |
          ghcr.io/skygenesisenterprise/${{ steps.extract-info.outputs.image_name }}:latest
          ghcr.io/skygenesisenterprise/${{ steps.extract-info.outputs.image_name }}:${{ steps.extract-info.outputs.version }}
        labels: |
          org.opencontainers.image.title=Sky Genesis ${{ steps.extract-info.outputs.type == 'web' && 'Web Client' || steps.extract-info.outputs.type == 'cli' && 'CLI' || steps.extract-info.outputs.type == 'service' && 'API Service' || 'All-in-One' }}
          org.opencontainers.image.description=${{ steps.extract-info.outputs.type == 'web' && 'Next.js frontend application' || steps.extract-info.outputs.type == 'cli' && 'Rust-based CLI with SSH server' || steps.extract-info.outputs.type == 'service' && 'Rust-based API service with SSH server' || 'Complete Sky Genesis stack with API, frontend, and CLI in single container' }}
          org.opencontainers.image.version=${{ steps.extract-info.outputs.version }}
        platforms: linux/amd64,linux/arm64
        cache-from: type=gha
        cache-to: type=gha,mode=max

    # Security scanning
    - name: Install Trivy
      uses: aquasecurity/trivy-action@master
      with:
        version: '0.50.1'

    - name: Scan ${{ steps.extract-info.outputs.type }} image for vulnerabilities
      run: |
        trivy image --exit-code 1 --no-progress --format sarif --output ${{ steps.extract-info.outputs.type }}-scan.sarif ghcr.io/skygenesisenterprise/${{ steps.extract-info.outputs.image_name }}:${{ steps.extract-info.outputs.version }}

    # Upload security scan results
    - name: Upload security scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: ${{ steps.extract-info.outputs.type }}-scan.sarif

    # Sign images
    - name: Install cosign
      uses: sigstore/cosign-installer@v3

    - name: Sign Docker image
      run: |
        cosign sign ghcr.io/skygenesisenterprise/${{ steps.extract-info.outputs.image_name }}:${{ steps.extract-info.outputs.version }}
      env:
        COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}

    # Generate SLSA provenance for all images
    - name: Generate SLSA provenance
      uses: slsa-framework/slsa-github-generator@v1
      with:
        base64-subjects: ghcr.io/skygenesisenterprise/${{ steps.extract-info.outputs.image_name }}:${{ steps.extract-info.outputs.version }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}